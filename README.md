# WRO-2022-Future-Engineers---Volterra-Future-Engineers

The folder that we have uploaded contains:
- A folder named “t-photos” with a normal photo of the team and a funny photo of the three members of the team: Lorenzo Moglioni, Lorenzo Cappellari and  Massimo Guido Maria Pescatori
- A folder named “v-photos” with six vehicle photos from every side, from top and bottom
- A folder named “video” with a text file with the link to the video loaded on YouTube. The video is public and accessible by link. It shows the vehicle driving autonomously.
- A folder named “schemes” that contains two schematic diagrams  of the electromechanical components illustrating all the elements (electronic components and motors) used in the vehicle and how they connect to each other.
- A folder named “src” that contains the code used to control the vehicle during the qualifying round and the final round.
- Two files named “2022_03_28-EV3-third.ev3” and “2022_05_20-EV3-nineteenth.ev3” which are old versions of the final code.

Before describing in details the programs we have implemented in order to let the robot perform in the qualifying round and the final round, let’s move on to illustrate the components that we have used for the robot and the way they are connected to each other.
The main component is the LEGO MINDSTORMS EV3 smart brick, which is the brain of the robot. 
Our programs need signals to be detected from the environment in order to implement the instructions that allow the robot to move in the right directions avoiding obstacles and collisions against the wall. 
The choice of the most suitable sensors has been a crucial and fundamental part of our project, since without precise information from the environment it is impossible for the program to give the right signals to the motors and to let the robot always perform the right movements.
The signals from the environment are detected by the Pixycam 2.1 for Lego, an EV3 ultrasonic sensor, an EV3 gyro sensor, an EV3 infra-red sensor used as a proximity sensor. All of them are connected to port 1, to port 2, to port 3 and to port 4. In the first instance we have chosen a colour sensor, but we have changed our minds and we have found more useful an infra-red sensor.
As an actuator we have used a power functions medium motor which is connected to port A and an EV3 medium motor which is connected to port B. Even in this case, the final choice was not the first choice. In first instance we have chosen an EV3 large motor. The reason why we changed our mind is the necessity of having a higher propulsion from the motor.
In order to upload the program on the LEGO MINDSTORMS EV3 smart brick, we have to use a software called LEGO MINDSTORMS EV3 Home Edition. It can be still downloaded from the official website. Unfortunately it is not updated anymore, even if it is still easily available
For an important competition such as the World Robot Olympiad, we have preferred to resort to a trusted technology. The drawback of this choice has been the difficulties in finding all the components and all the cables needed to connect them. Anyway we are definitely convinced that this has been the right decision in order to achieve the best performances for our robot both in the qualifying round and the final round.
For both the qualifying round and the final round, we created two programs: one for clockwise and one for counter-clockwise. Therefore the programs we have implemented are four: one for the qualifying round for clockwise, one for the qualifying round for counter-clockwise, one for the final round for clockwise, one the final round for counter-clockwise.
Clockwise and anti-clockwise programs differ in major parts such as all the steering instructions and selection statements which are used to manage the correct flow of the instruction, therefore it is managed the correct behaviour expected by the robot while doing its competitions.

First of all, let us dwell on the illustration of the final round program.
We have implemented five iterative cycles:
1) A first cycle aims to make the motor speed compatible with EV3. The Unregulated MotorBlock is used for this purpose, which is a block that can activate a motor and control its power level. The selected motor is on the A port. A signal is repeatedly sent to the power function motor to keep it working, every signal impulse is slightly different; even though the value changes are hardly noticeable, in a default-true condition  iterative loop, the value of the impulse at the end is always brought back the same as the original.
2) A second cycle controls a status variable. This status variable is set to 1 if the wall is detected at a distance lower than 80 centimeters, otherwise it is set to 0 either if it detects other objects or if it detects neither the wall nor other objects.
3) The third cycle is the cycle that handles the behaviour in the presence of obstacles. When an obstacle is detected, the robot establish a position aligned with the block, after several loops, in order to detect it. When it is near to the obstacle, it decreases the speed and moves in the direction left-right, depending on the colour of the block. 
4) The fourth loop is the loop that deals with handling behaviour in the presence of the wall. The angle is continuously detected by a gyro sensor, its absolute value and the modulus of 90 is computed and it is compared to 80° to see if it is higher than 80° . If the result of this comparison is true or if an obstacle is detected, the robot changes its direction in order to avoid the obstacles and to set the direction of the path. 
5) The last cycle is not really a cycle, but a real program whose purpose is to check the end of the final round after three laps have been run. Therefore it waits until the gyro sensor detects that three laps have been run.
Let’s move on to the illustration of the qualifying round
The program is based on status variables as well as the final round program. There is a continuous loop  that is independent on the others which controls if the wall is detected (and in this case it sets the variable to 1) or if the wall is not detected (and in this case it sets the variable to 0).  We have implemented two different cycles indeed: one which checks if the wall is detected and one which checks if the wall is not detected. The two cycles are managed in a way that prevents each cycle to conflict with the other causing malfunctioning in the robot movements.
Other two independent cycles manage the rotation and the alignment of the robot, which is crucial for the complex maneuvers.
While in the final round, the robot alignes itself when it detects the obstacles, in the qualifying round if the wall is not detected , a function is activated that does a steering equal to how crooked the gyroscope is in relation to the direction the robot is moving to. The steering should be proportional to the angle plus a small adjustment coefficient.
